## Default values for reposilite.
image:
  name: dzikoysk/reposilite
  tag: "" # defaults to appVersion
  pullPolicy: IfNotPresent

## Name overrides
nameOverride: ""
fullnameOverride: ""

## Deployment configuration
deployment:
  # Number of replicas to be deployed.
  replicas: 1
  # Time in seconds before Kubernetes sends a SIGKILL signal if Reposilite doesn't gracefully shut down.
  terminationGracePeriodSeconds: 60
  # The minimum time in seconds Reposilite needs to be running before the Deployment controller considers it available.
  minReadySeconds: 0
  # Additional annotations to be added to the Deployment
  annotations: {}
  # Additional labels to be added to the Deployment
  labels: {}
  # Additional annotations to be added to pods
  podAnnotations: {}
  # Additional labels to be added to pods
  podLabels: {}
  # Init containers
  initContainers: []
    # - name: name
    #   image: alpine
    #   args: []
    #   volumeMounts:
    #     - name: volume-name
    #       mountPath: /data
  # Additional containers
  additionalContainers: []
    # - name: name
    #   image: alpine
    #   args: []
    #   volumeMounts:
    #     - name: volume-name
    #       mountPath: /data
  # Additional volumes for use with initContainers, additionalContainers and runtime container itself
  additionalVolumes: []
    # - name: name
    #   hostPath:
    #     path: /tmp
    # - name: logging
    #   emptyDir: {}
  # Additional mount points for the runtime container. Refer to volumes defined in `additionalVolumes`.
  additionalVolumeMounts: []
    # - name: logging
    #   mountPath: /var/log/reposilite/
  # Image pull secrets
  imagePullSecrets: []
  lifecycle: {}
    # preStop:
    #   exec:
    #     command: ["/bin/sh", "-c", "sleep 40"]
    # postStart:
    #   httpGet:
    #     path: /
    #     port: 8080
    #     host: localhost
    #     scheme: http
  # Security context for all initContainers and containers in the pod
  podSecurityContext:
    enabled: false
    fsGroup: 999
  # Security context specific to the runtime container in the pod.
  containerSecurityContext:
    enabled: false
    runAsUser: 999
    runAsGroup: 999


## Service configuration
services:
  http:
    enabled: true
    annotations: {}
    externalIPs: []
    externalTrafficPolicy: "Cluster"
    internalTrafficPolicy: "Cluster"
    ipFamilies: []
    labels: {}
    loadBalancerClass: ""
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    port: 8080
    sessionAffinity: "None"
    sessionAffinityConfig: {}
    type: "ClusterIP"

## @section Horizontal Pod Autoscaler (HPA)
# In order for the HPA to function successfully, a metric server is required, especially for resource consumption. The
# metric server enables the CPU and memory utilisation to be recorded. If such a metric server is not available, the HPA
# cannot scale pods based on CPU or memory utilisation. Further information be be found here:
# https://github.com/kubernetes-sigs/metrics-server#deployment
hpa:
  ## @param hpa.enabled Enable the horizontal pod autoscaler (HPA).
  ## @param hpa.annotations Additional annotations for the HPA.
  ## @param hpa.labels Additional labels for the HPA.
  ## @param.hpa.behavior.scaleDown Scaling policy for scaling down.
  ## @skip.hpa.behavior.scaleDown.policies Skip individual scale down policies.
  ## @skip.hpa.behavior.scaleDown.stabilizationWindowSeconds Skip individual stabilizationWindowSeconds.
  ## @param hpa.metrics Metrics contains the specifications for which to use to calculate the desired replica count.
  ## @skip hpa.metrics Skip individual HPA metric configurations.
  ## @param hpa.minReplicas Min replicas is the lower limit for the number of replicas to which the autoscaler can scale down.
  ## @param hpa.maxReplicas Upper limit for the number of pods that can be set by the autoscaler.
  enabled: false
  annotations: {}
  labels: {}
  behavior:
    scaleDown:
      policies:
      - type: Pods
        value: 1
        periodSeconds: 60
      stabilizationWindowSeconds: 300
  metrics:
  - resource:
      name: cpu
      target:
        averageUtilization: 65
        type: Utilization
    type: Resource
  - resource:
      name: memory
      target:
        averageUtilization: 65
        type: Utilization
    type: Resource
  minReplicas: 1
  maxReplicas: 10

## If you would like to create an ingress for Reposilite's frontend, you can enable it here.
## Please refer to your ingress provider's documentation for configuration that may be specific
## to their ingress implementation.
ingress:
  enabled: false
  className: "nginx"
  annotations: {}
    # Using backend-protocol annotations is possible to indicate how NGINX should communicate with the backend service.
    # (Replaces secure-backends in older versions) Valid Values: HTTP, HTTPS, AUTO_HTTP, GRPC, GRPCS and FCGI.
    # https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md#backend-protocol
    # nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"

    # For NGINX, an 413 error will be returned to the client when the size in a request exceeds the maximum allowed size
    # of the client request body. This size can be configured by the parameter client_max_body_size.
    # https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md#custom-max-body-size
    # nginx.ingress.kubernetes.io/proxy-body-size: "128m"

    # Specifies a Secret with the certificate tls.crt, key tls.key in PEM format used for authentication to a proxied
    # HTTPS server. It should also contain trusted CA certificates ca.crt in PEM format used to verify the certificate
    # of the proxied HTTPS server. This annotation expects the Secret name in the form "namespace/secretName"
    # https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md#backend-certificate-authentication
    # nginx.ingress.kubernetes.io/proxy-ssl-secret: ""

    # Enables the specified protocols for requests to a proxied HTTPS server.
    # https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md#backend-certificate-authentication
    # nginx.ingress.kubernetes.io/proxy-ssl-protocols: "TLSv1.2 TLSv1.3"

    # Allows to set proxy_ssl_name. This allows overriding the server name used to verify the certificate of the proxied
    # HTTPS server. This value is also passed through SNI when a connection is established to the proxied HTTPS server.
    # https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md#backend-certificate-authentication
    # nginx.ingress.kubernetes.io/proxy-ssl-server-name: "{{ include \"reposilite.fullname\" $ }}"

    # Enables or disables verification of the proxied HTTPS server certificate.
    # https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md#backend-certificate-authentication
    # nginx.ingress.kubernetes.io/proxy-ssl-verify: "on"
  labels: {}
  hosts: []
  # - host: reposilite.example.local
  #   paths:
  #     - path: /
  #       pathType: Prefix
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

## Resources
resources:
  requests:
    cpu: 1.0
    memory: 128Mi
  limits:
    cpu: 2.0
    memory: 256Mi

## Environment variables
env:
  - name: JAVA_OPTS
    value: "-Xmx64M"
#  - name: REPOSILITE_OPTS
#    value: "--port 8080"
#  - name: SOME_VAR_FROM_CONFIG_MAP
#    valueFrom:
#      configMapRef:
#        name: config-name
#        key: config-key
#  - name: SOME_VAR_FROM_SECRET
#    valueFrom:
#      secretKeyRef:
#        name: secret-name
#        key: secret-key

## Environment variables from
envFrom: []
# - configMapRef:
#     name: config-map-name
# - secretRef:
#     name: secret-name

## Rolling update
rollingUpdate:
  maxUnavailable: 0
  maxSurge: 1

## Persistent Volume Claim
## Ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/
## RECOMMENDED: This is required to persist configuration changes and artifacts!
persistence:
  enabled: true
  name: "data"
  size: 4Gi
# storageClass: "" # Use this if you wish to define a StorageClass to use.
  accessMode: ReadWriteOnce
  annotations: {}
# existingClaim: "" # Use this if you already have an existing PVC for Reposilite.
  path: /app/data
# subPath: "" # Only mount a subdirectory of the Volume to the pod.

## Service account
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""
  automountServiceAccountToken: false

## Pod affinity
affinity: {}

## Pod node selector
nodeSelector: {}

## Pod tolerations
tolerations: []
