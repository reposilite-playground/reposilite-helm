## Default values for reposilite.
image:
  name: docker.io/dzikoysk/reposilite
  tag: "" # defaults to appVersion
  pullPolicy: IfNotPresent

## Name overrides
nameOverride: ""
fullnameOverride: ""

## Deployment configuration
deployment:
  # Number of replicas to be deployed.
  replicas: 1
  # Time in seconds before Kubernetes sends a SIGKILL signal if Reposilite doesn't gracefully shut down.
  terminationGracePeriodSeconds: 60
  # The minimum time in seconds Reposilite needs to be running before the Deployment controller considers it available.
  minReadySeconds: 0
  # Additional annotations to be added to the Deployment
  annotations: {}
  # Additional labels to be added to the Deployment
  labels: {}
  # Additional annotations to be added to pods
  podAnnotations: {}
  # Additional labels to be added to pods
  podLabels: {}
  # Init containers
  initContainers: []
    # - name: name
    #   image: alpine
    #   args: []
    #   volumeMounts:
    #     - name: volume-name
    #       mountPath: /data
  # Additional containers
  additionalContainers: []
    # - name: name
    #   image: alpine
    #   args: []
    #   volumeMounts:
    #     - name: volume-name
    #       mountPath: /data
  # Additional volumes for use with initContainers, additionalContainers and runtime container itself
  additionalVolumes: []
    # - name: name
    #   hostPath:
    #     path: /tmp
    # - name: logging
    #   emptyDir: {}
  # Additional mount points for the runtime container. Refer to volumes defined in `additionalVolumes`.
  additionalVolumeMounts: []
    # - name: logging
    #   mountPath: /var/log/reposilite/
  # Image pull secrets
  imagePullSecrets: []
  lifecycle: {}
    # preStop:
    #   exec:
    #     command: ["/bin/sh", "-c", "sleep 40"]
    # postStart:
    #   httpGet:
    #     path: /
    #     port: 8080
    #     host: localhost
    #     scheme: http
  # Security context for all initContainers and containers in the pod
  podSecurityContext:
    enabled: false
    fsGroup: 999
  # Security context specific to the runtime container in the pod.
  containerSecurityContext:
    enabled: false
    runAsUser: 999
    runAsGroup: 999

## @section Horizontal Pod Autoscaler (HPA)
# In order for the HPA to function successfully, a metric server is required, especially for resource consumption. The
# metric server enables the CPU and memory utilisation to be recorded. If such a metric server is not available, the HPA
# cannot scale pods based on CPU or memory utilisation. Further information be be found here:
# https://github.com/kubernetes-sigs/metrics-server#deployment
hpa:
  ## @param hpa.enabled Enable the horizontal pod autoscaler (HPA).
  ## @param hpa.annotations Additional annotations for the HPA.
  ## @param hpa.labels Additional labels for the HPA.
  ## @param.hpa.behavior.scaleDown Scaling policy for scaling down.
  ## @skip.hpa.behavior.scaleDown.policies Skip individual scale down policies.
  ## @skip.hpa.behavior.scaleDown.stabilizationWindowSeconds Skip individual stabilizationWindowSeconds.
  ## @param hpa.metrics Metrics contains the specifications for which to use to calculate the desired replica count.
  ## @skip hpa.metrics Skip individual HPA metric configurations.
  ## @param hpa.minReplicas Min replicas is the lower limit for the number of replicas to which the autoscaler can scale down.
  ## @param hpa.maxReplicas Upper limit for the number of pods that can be set by the autoscaler.
  enabled: false
  annotations: {}
  labels: {}
  behavior:
    scaleDown:
      policies:
      - type: Pods
        value: 1
        periodSeconds: 60
      stabilizationWindowSeconds: 300
  metrics:
  - resource:
      name: cpu
      target:
        averageUtilization: 65
        type: Utilization
    type: Resource
  - resource:
      name: memory
      target:
        averageUtilization: 65
        type: Utilization
    type: Resource
  minReplicas: 1
  maxReplicas: 10

## @section Ingress
ingress:
  ## @param ingress.enabled Enable creation of an ingress resource. Requires, that the http service is also enabled.
  ## @param ingress.className Ingress class.
  ## @param ingress.annotations Additional ingress annotations.
  ## @param ingress.labels Additional ingress labels.
  enabled: false
  className: "nginx"
  annotations: {}
  labels: {}

  ## @param ingress.hosts Ingress specific configuration. Let ingress controller listen on specific DNS names and path's.
  ## @skip ingress.hosts Skip individual host configuration.
  hosts: []
  # - host: reposilite.example.local
  #   paths:
  #     - path: /
  #       pathType: Prefix

  ## @param ingress.tls Ingress specific TLS configuration. Use TLS encryption for specific hostnames.
  ## @skip ingress.tls Skip individual TLS configuration.
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

## @section networkPolicy
networkPolicy:
  ## @param networkPolicy.enabled Enable network policies in general.
  ## @param networkPolicy.annotations Additional network policy annotations.
  ## @param networkPolicy.labels Additional network policy labels.
  ## @param networkPolicy.policyTypes List of policy types. Supported is ingress, egress or ingress and egress.
  ## @param networkPolicy.egress Concrete egress network policy implementation.
  ## @skip networkPolicy.egress Skip individual egress configuration.
  ## @param networkPolicy.ingress Concrete ingress network policy implementation.
  ## @skip networkPolicy.ingress Skip individual ingress configuration.
  enabled: false
  annotations: {}
  labels: {}
  policyTypes: []
  # - Egress
  # - Ingress
  egress: []
  # Allow outgoing DNS traffic to the internal running DNS-Server. For example core-dns.
  #
  # - to:
  #   - namespaceSelector:
  #       matchLabels:
  #         kubernetes.io/metadata.name: kube-system
  #     podSelector:
  #       matchLabels:
  #        k8s-app: kube-dns
  #   ports:
  #   - port: 53
  #     protocol: TCP
  #   - port: 53
  #     protocol: UDP

  ingress: []
  # Allow incoming HTTP traffic from prometheus.
  #
  # - from:
  #   - namespaceSelector:
  #       matchLabels:
  #         kubernetes.io/metadata.name: monitoring
  #     podSelector:
  #       matchLabels:
  #         app.kubernetes.io/name: prometheus
  #   ports:
  #   - port: http
  #     protocol: TCP

  # Allow incoming HTTP traffic from ingress-nginx.
  #
  # - from:
  #   - namespaceSelector:
  #       matchLabels:
  #         kubernetes.io/metadata.name: ingress-nginx
  #     podSelector:
  #       matchLabels:
  #         app.kubernetes.io/name: ingress-nginx
  #   ports:
  #   - port: http
  #     protocol: TCP

## @section Service
## @param service.enabled Enable the service.
## @param service.annotations Additional service annotations.
## @param service.externalIPs External IPs for the service.
## @param service.externalTrafficPolicy If `service.type` is `NodePort` or `LoadBalancer`, set this to `Local` to tell kube-proxy to only use node local endpoints for cluster external traffic. Furthermore, this enables source IP preservation.
## @param service.internalTrafficPolicy If `service.type` is `NodePort` or `LoadBalancer`, set this to `Local` to tell kube-proxy to only use node local endpoints for cluster internal traffic.
## @param service.ipFamilies IPFamilies is list of IP families (e.g. `IPv4`, `IPv6`) assigned to this service. This field is usually assigned automatically based on cluster configuration and only required for customization.
## @param service.labels Additional service labels.
## @param service.loadBalancerClass LoadBalancerClass is the class of the load balancer implementation this Service belongs to. Requires service from type `LoadBalancer`.
## @param service.loadBalancerIP LoadBalancer will get created with the IP specified in this field. Requires service from type `LoadBalancer`.
## @param service.loadBalancerSourceRanges Source range filter for LoadBalancer. Requires service from type `LoadBalancer`.
## @param service.port Port to forward the traffic to.
## @param service.sessionAffinity Supports `ClientIP` and `None`. Enable client IP based session affinity via `ClientIP`.
## @param service.sessionAffinityConfig Contains the configuration of the session affinity.
## @param service.type Kubernetes service type for the traffic.
service:
  enabled: true
  annotations: {}
  externalIPs: []
  externalTrafficPolicy: "Cluster"
  internalTrafficPolicy: "Cluster"
  ipFamilies: []
  labels: {}
  loadBalancerClass: ""
  loadBalancerIP: ""
  loadBalancerSourceRanges: []
  port: 8080
  sessionAffinity: "None"
  sessionAffinityConfig: {}
  type: "ClusterIP"

## Resources
resources:
  requests:
    cpu: 1.0
    memory: 128Mi
  limits:
    cpu: 2.0
    memory: 256Mi

## Environment variables
env:
  - name: JAVA_OPTS
    value: "-Xmx64M"
#  - name: REPOSILITE_OPTS
#    value: "--port 8080"
#  - name: SOME_VAR_FROM_CONFIG_MAP
#    valueFrom:
#      configMapRef:
#        name: config-name
#        key: config-key
#  - name: SOME_VAR_FROM_SECRET
#    valueFrom:
#      secretKeyRef:
#        name: secret-name
#        key: secret-key

## Environment variables from
envFrom: []
# - configMapRef:
#     name: config-map-name
# - secretRef:
#     name: secret-name

## Rolling update
rollingUpdate:
  maxUnavailable: 0
  maxSurge: 1

## Persistent Volume Claim
## Ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/
## RECOMMENDED: This is required to persist configuration changes and artifacts!
persistence:
  enabled: true
  name: "data"
  size: 4Gi
# storageClass: "" # Use this if you wish to define a StorageClass to use.
  accessMode: ReadWriteOnce
  annotations: {}
# existingClaim: "" # Use this if you already have an existing PVC for Reposilite.
  path: /app/data
# subPath: "" # Only mount a subdirectory of the Volume to the pod.

## Service account
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""
  automountServiceAccountToken: false

## Pod affinity
affinity: {}

## Pod node selector
nodeSelector: {}

## Pod tolerations
tolerations: []
